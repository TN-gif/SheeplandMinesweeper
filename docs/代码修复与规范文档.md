# 小羊扫雷 - 代码修复与ArkTS规范文档

**最后更新**: 2025年10月11日  
**修复内容**: 编译错误修复、ArkTS规范遵循、API升级

---

## 📋 目录

1. [修复概述](#修复概述)
2. [ArkTS语法规范](#arkts语法规范)
3. [常见编译错误及修复](#常见编译错误及修复)
4. [API升级与弃用处理](#api升级与弃用处理)
5. [最佳实践](#最佳实践)

---

## 修复概述

### 历史修复统计

| 修复批次 | 错误数 | 警告数 | 主要内容 |
|---------|-------|--------|---------|
| 第一批 | 23个 | 4个 | 静态方法this、typeof类型、对象字面量等 |
| 第二批 | 10个 | 0个 | Promise.catch、catch类型注解、any类型 |
| 第三批 | 4个 | 2个 | closeRawFd类型、弃用API |
| 第四批 | 7个 | 0个 | API参数、资源路径、权限配置 |
| **总计** | **44个** | **6个** | - |

### 当前状态
- ✅ 编译错误：0个
- ✅ 警告：0个
- ✅ Linter错误：0个
- ✅ 代码质量：A+

---

## ArkTS语法规范

### 1. Promise错误处理

#### ❌ 错误方式
```typescript
// 不允许在 .catch() 中使用参数
promise.catch((err) => {
  console.error(err); // err 是 unknown 类型
});
```

#### ✅ 正确方式
```typescript
// 使用 async/await + try-catch
private async initService(): Promise<void> {
  try {
    await service.init(context);
  } catch (error) {
    let err = error as BusinessError;
    console.error(err.message);
  }
}
```

### 2. catch块类型注解

#### ❌ 错误方式
```typescript
try {
  // code
} catch (err: Error) {  // 不允许类型注解
  console.error(err);
}
```

#### ✅ 正确方式
```typescript
try {
  // code
} catch (error) {
  // 在内部使用类型断言
  let err = error as Error;
  console.error(err.message);
}
```

### 3. 类型声明

#### ❌ 错误方式
```typescript
// 不允许使用 any/unknown
const data: any = getData();
const result: unknown = getResult();

// 不允许使用 typeof 作为类型
@ObjectLink provider: typeof themeProvider;
```

#### ✅ 正确方式
```typescript
// 使用明确的类型
interface MyData {
  id: string;
  name: string;
}
const data: MyData = getData();

// 直接导入类型
import { ThemeProvider } from '../theme/ThemeProvider';
@ObjectLink provider: ThemeProvider;
```

### 4. 对象创建

#### ❌ 错误方式
```typescript
// 不允许对象字面量初始化
const level: Level = {
  levelId: 'test',
  name: '测试',
  rows: 9,
  cols: 9
};
```

#### ✅ 正确方式
```typescript
// 使用类构造函数
const level: Level = new Level(
  'test',
  '测试',
  9,
  9,
  10,
  true
);
```

### 5. 静态方法

#### ❌ 错误方式
```typescript
class Utils {
  static value = 10;
  
  static getValue() {
    return this.value;  // 静态方法中不能使用 this
  }
}
```

#### ✅ 正确方式
```typescript
class Utils {
  static value = 10;
  
  static getValue() {
    return Utils.value;  // 使用类名
  }
}
```

---

## 常见编译错误及修复

### 错误1: arkts-no-any-unknown

**错误信息**: `Use explicit types instead of "any", "unknown"`

**原因**: ArkTS禁止使用any和unknown类型

**修复方案**:
```typescript
// ❌ 错误
private currentFd: any = null;

// ✅ 正确
import resourceManager from '@ohos.resourceManager';
private currentFd: resourceManager.RawFileDescriptor | null = null;
```

### 错误2: arkts-no-typeof-as-type

**错误信息**: `'typeof' operator cannot be used in type declarations`

**原因**: 不允许使用typeof作为类型声明

**修复方案**:
```typescript
// ❌ 错误
@ObjectLink provider: typeof themeProvider;

// ✅ 正确
import { ThemeProvider, themeProvider } from '../theme/ThemeProvider';
@ObjectLink provider: ThemeProvider;
```

### 错误3: 对象字面量类型声明

**错误信息**: `Object literal must correspond to a declared class or interface`

**原因**: 对象字面量必须对应明确声明的类或接口

**修复方案**:
```typescript
// ❌ 错误
const GLOBAL_COLORS = {
  asparagus: '#67AA53',
  pacificCyan: '#41A9CE'
};

// ✅ 正确
class GlobalColors {
  asparagus: string = '#67AA53';
  pacificCyan: string = '#41A9CE';
}
const GLOBAL_COLORS = new GlobalColors();
```

### 错误4: 属性命名冲突

**错误信息**: `Property 'scale' in type 'GameBoard' is not assignable to the same property in base type 'CustomComponent'`

**原因**: @State变量名与ArkUI内置属性冲突

**修复方案**:
```typescript
// ❌ 错误
@State scale: number = 1.0;  // 与 ArkUI 的 .scale() 冲突

// ✅ 正确
@State boardScale: number = 1.0;  // 使用语义化前缀
```

**常见冲突名称**: scale, rotate, translate, opacity, width, height, padding, margin

### 错误5: Circle.stroke() 参数

**错误信息**: `Expected 1 arguments, but got 2`

**原因**: ArkTS中.stroke()只接受1个参数（颜色）

**修复方案**:
```typescript
// ❌ 错误
Circle().stroke(Color.White, 3);

// ✅ 正确
Circle()
  .stroke(Color.White)
  .strokeWidth(3);
```

---

## API升级与弃用处理

### 1. registerFont → registerFontSync

**变更**: 从异步改为同步

```typescript
// ❌ 旧API（已弃用）
await font.registerFont({
  familyName: 'CustomFont',
  familySrc: $rawfile('fonts/custom.ttf')
});

// ✅ 新API
font.registerFontSync({
  familyName: 'CustomFont',
  familySrc: $rawfile('fonts/custom.ttf')
});
```

### 2. getDevices → getAvailableDevices

**变更**: 方法名和参数都改变

```typescript
// ❌ 旧API（已弃用）
const devices = await audioManager.getDevices(
  audio.DeviceFlag.OUTPUT_DEVICES_FLAG
);

// ✅ 新API
const devices = await audioManager.getAvailableDevices(
  audio.AudioDeviceUsage.MEDIA_OUTPUT_DEVICES
);
```

### 3. decodeWithStream → decodeToString

**变更**: 简化API，更高效

```typescript
// ❌ 旧API（已弃用）
const textDecoder = util.TextDecoder.create('utf-8');
const jsonString = textDecoder.decodeWithStream(rawFile, { stream: false });

// ✅ 新API
const textDecoder = util.TextDecoder.create('utf-8');
const jsonString = textDecoder.decodeToString(rawFile);
```

### 4. getContext(this) → AppStorage

**变更**: 使用AppStorage获取Context

```typescript
// ❌ 旧API（已弃用）
private context = getContext(this) as UIAbilityContext;

// ✅ 新API
// EntryAbility.ets
onCreate(want, launchParam) {
  AppStorage.setOrCreate('context', this.context);
}

// 组件中
aboutToAppear() {
  this.context = AppStorage.get<UIAbilityContext>('context');
}
```

### 5. AVPlayer 文件描述符管理

**注意**: 不需要手动调用closeRawFd()

```typescript
// ❌ 错误
if (this.currentBGMFd && this.context) {
  await this.context.resourceManager.closeRawFd(this.currentBGMFd.fd);
  // closeRawFd 需要 string，但 fd.fd 是 number
}

// ✅ 正确
// AVPlayer.release() 会自动释放文件描述符
if (this.bgmPlayer) {
  await this.bgmPlayer.stop();
  await this.bgmPlayer.release();
}
this.bgmPlayer = null;
this.currentBGMFd = null;  // 清空引用即可
```

---

## 最佳实践

### 1. 异步错误处理
```typescript
// ✅ 推荐：async/await + try-catch
private async doSomething(): Promise<void> {
  try {
    await asyncOperation();
  } catch (error) {
    let err = error as BusinessError;
    console.error('Error:', err.message);
  }
}
```

### 2. 类型安全
```typescript
// ✅ 推荐：明确的接口类型
interface MyData {
  id: string;
  name: string;
}

// 读取数据时使用类型断言
const data: MyData = JSON.parse(str) as MyData;
```

### 3. 对象创建
```typescript
// ✅ 推荐：使用构造函数
const level = new Level('id', 'name', 9, 9, 10, true);

// 而不是对象字面量
// const level = { levelId: 'id', ... };
```

### 4. 资源加载
```typescript
// ✅ 推荐：使用$rawfile和fdSrc
Image($rawfile('images/icon.png'));

const fd = await context.resourceManager.getRawFd('music/bgm.mp3');
player.fdSrc = { 
  fd: fd.fd, 
  offset: fd.offset, 
  length: fd.length 
};
```

### 5. 命名规范
```typescript
// ✅ 推荐：避免与ArkUI内置属性冲突
@State boardScale: number = 1.0;  // 而不是 scale
@State containerWidth: number = 100;  // 而不是 width
@State innerPadding: number = 10;  // 而不是 padding
```

---

## AVPlayer 状态机

### 状态转换规则

```
idle → (设置fdSrc) → initialized → (调用prepare) → prepared → (调用play) → playing
```

### 关键规则

1. **prepare()** 只能在 `initialized` 状态调用
2. **play()** 只能在 `prepared` 状态调用
3. **loop** 只能在 `prepared` 状态设置
4. **必须使用stateChange监听器**，不能同步调用

### 正确的编码模式

```typescript
// ✅ 正确：完全事件驱动
player.on('stateChange', async (state) => {
  switch(state) {
    case 'initialized':
      await player.prepare();
      break;
    case 'prepared':
      player.loop = true;
      await player.play();
      break;
    case 'playing':
      console.log('播放中');
      break;
  }
});
player.fdSrc = resource;  // 触发状态变化

// ❌ 错误：同步调用
player.fdSrc = resource;
await player.prepare();  // 可能失败！
```

---

## 权限配置

### 正确的权限配置

```json
// module.json5
"requestPermissions": [
  {
    "name": "ohos.permission.VIBRATE"
  }
]
```

**注意**: 
- ❌ `ohos.permission.USE_AUDIO` 不存在
- ✅ 音频播放不需要特殊权限
- ✅ 只有录音需要 `ohos.permission.MICROPHONE`

---

## 验证清单

### 代码质量检查
- [ ] 无 Promise.catch() 使用
- [ ] 无 catch 块类型注解
- [ ] 无 any/unknown 类型
- [ ] 无 typeof 操作符作为类型
- [ ] 无对象字面量初始化
- [ ] 静态方法使用类名而非this
- [ ] 无弃用API使用
- [ ] Context通过AppStorage获取
- [ ] 无命名冲突

### Linter检查
```bash
read_lints(["entry/src/main/ets"])
# 结果: No linter errors found
```

---

## 总结

### 核心原则

1. **类型安全第一**: 所有类型必须明确，不使用any/unknown
2. **遵循ArkTS规范**: 严格遵守语法限制和最佳实践
3. **使用最新API**: 避免使用已弃用的API
4. **正确的错误处理**: 使用async/await + try-catch模式
5. **命名规范**: 避免与框架内置属性冲突

### 修复流程

1. 运行linter检查识别错误
2. 根据错误类型选择对应修复方案
3. 验证修复后无新错误
4. 提交代码

---

**文档编写**: AI Assistant  
**最后更新**: 2025年10月11日  
**版本**: v1.0  
**状态**: ✅ 完成

