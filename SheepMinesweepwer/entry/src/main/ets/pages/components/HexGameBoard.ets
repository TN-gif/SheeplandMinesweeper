import { HexGameViewModel } from '../viewModel/HexGameViewModel';
import { HexUtils, AxialCoord, HexCell, Point } from '../model/HexUtils';
import { themeProvider } from '../theme/ThemeProvider';
import { audioManager } from '../services/AudioManager';

class CanvasSize {
  width: number = 0;
  height: number = 0;
}

@Component
export struct HexGameBoard {
  @ObjectLink viewModel: HexGameViewModel;
  private canvasContext: CanvasRenderingContext2D | null = null;
  private canvasSize: CanvasSize = new CanvasSize();
  private hexSize: number = 30; // Radius of a hexagon in pixels
  private origin: Point = new Point(0, 0);
  private longPressTimer: number = -1;
  private longPressCoord: AxialCoord | null = null;
  @State needsRedraw: number = 0; // ç”¨äºŽè§¦å‘é‡ç»˜

  private onReady() {
    this.draw();
  }

  private draw(): void {
    if (!this.canvasContext) return;
    const ctx: CanvasRenderingContext2D = this.canvasContext;
    ctx.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);

    this.viewModel.board.forEach((cell: HexCell) => {
      const cellCoord: AxialCoord = new AxialCoord(cell.q, cell.r);
      const center: Point = HexUtils.axialToPixel(cellCoord, this.hexSize, this.origin);
      this.drawHex(ctx, center, cell);
      this.drawHexContent(ctx, center, cell);
    });
  }

  private drawHex(ctx: CanvasRenderingContext2D, center: Point, cell: HexCell): void {
    ctx.beginPath();
    for (let i: number = 0; i < 6; i++) {
      const angle: number = (Math.PI / 180) * (60 * i);
      const x: number = center.x + this.hexSize * Math.cos(angle);
      const y: number = center.y + this.hexSize * Math.sin(angle);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    
    // æ ¹æ®çŠ¶æ€è®¾ç½®é¢œè‰²
    if (cell.isRevealed) {
      if (cell.isMine) {
        ctx.fillStyle = '#FFE4E1'; // åœ°é›·æ—¶çš„çº¢è‰²èƒŒæ™¯
      } else if (cell.adjacentMines > 0) {
        ctx.fillStyle = '#F5F5DC'; // æœ‰æ•°å­—æ—¶çš„æµ…é»„è‰²èƒŒæ™¯
      } else {
        ctx.fillStyle = '#B9D8A5'; // ç¿»å¼€æ— æ•°å­—æ—¶çš„è‰åœ°è‰²
      }
    } else {
      ctx.fillStyle = '#D2B48C'; // æœªç¿»å¼€æ—¶çš„åœŸåœ°è‰²
    }
    ctx.fill();
    
    ctx.strokeStyle = cell.isRevealed ? '#98B888' : '#A0856C';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  private drawHexContent(ctx: CanvasRenderingContext2D, center: Point, cell: HexCell): void {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (cell.isFlagged) {
      ctx.font = 'bold 20px sans-serif';
      ctx.fillText('âš‘', center.x, center.y);
    } else if (cell.isRevealed) {
      if (cell.isMine) {
        ctx.font = '20px sans-serif';
        ctx.fillText('ðŸº', center.x, center.y);
      } else if (cell.adjacentMines > 0) {
        ctx.font = 'bold 20px sans-serif';
        const colors: string[] = ['', '#67AA53', '#41A9CE', '#FF4444', '#9C27B0', '#FF6F00', '#00BCD4'];
        ctx.fillStyle = colors[Math.min(cell.adjacentMines, colors.length - 1)];
        ctx.fillText(cell.adjacentMines.toString(), center.x, center.y);
      }
    }
  }

  private handleTouchStart(event: TouchEvent): void {
    if (!event || !event.touches || event.touches.length === 0) return;
    
    const touch: TouchObject = event.touches[0];
    const touchX: number = touch.x;
    const touchY: number = touch.y;
    const tappedHex: AxialCoord = HexUtils.pixelToAxial(touchX, touchY, this.hexSize, this.origin);
    
    // ä¿å­˜åæ ‡ç”¨äºŽé•¿æŒ‰
    this.longPressCoord = tappedHex;
    
    // å¯åŠ¨é•¿æŒ‰å®šæ—¶å™¨ï¼ˆ500msè§¦å‘æ’æ——ï¼‰
    this.longPressTimer = setTimeout(() => {
      if (this.longPressCoord) {
        this.viewModel.flagCell(this.longPressCoord.q, this.longPressCoord.r);
        audioManager.playSound('flag');
        this.draw();
        this.needsRedraw++; // è§¦å‘çŠ¶æ€æ›´æ–°
      }
    }, 500);
  }

  private handleTouchEnd(event: TouchEvent): void {
    // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
    if (this.longPressTimer >= 0) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = -1;
    }
    
    // å¦‚æžœåæ ‡å­˜åœ¨ä¸”å®šæ—¶å™¨åˆšè¢«æ¸…é™¤ï¼Œè¯´æ˜Žæ˜¯çŸ­æŒ‰ï¼ˆç¿»å¼€ï¼‰
    if (this.longPressCoord && event.touches.length === 0) {
      this.viewModel.revealCell(this.longPressCoord.q, this.longPressCoord.r);
      audioManager.playSound('click');
      this.draw();
      this.needsRedraw++;
      this.longPressCoord = null;
    }
  }

  private handleTouchCancel(): void {
    // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
    if (this.longPressTimer >= 0) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = -1;
    }
    this.longPressCoord = null;
  }

  build() {
    Canvas(this.canvasContext)
      .width('100%')
      .height('100%')
      .onReady(() => {
        this.onReady();
      })
      .onTouch((event: TouchEvent) => {
        if (event.type === TouchType.Down) {
          this.handleTouchStart(event);
        } else if (event.type === TouchType.Up) {
          this.handleTouchEnd(event);
        } else if (event.type === TouchType.Cancel) {
          this.handleTouchCancel();
        }
      })
      .onAreaChange((oldValue: Area, newValue: Area) => {
        if (newValue && newValue.width && newValue.height) {
          this.canvasSize.width = newValue.width as number;
          this.canvasSize.height = newValue.height as number;
          this.origin = new Point(this.canvasSize.width / 2, this.canvasSize.height / 2);
          this.draw();
        }
      });
  }
}
